import { Actor } from './actor'
import { Text } from './text'
import { Graph } from './graph'
import { Node2D, StateOfNode2D } from './node'
import { HybridState } from './statesOfAutoAGV/HybridState'
import { RunningState } from './statesOfAutoAGV/RunningState'
import { MainScene } from '../scenes'
import uniqid from 'uniqid'
import * as socketEvents from '../socketEvents' // Generated by https://quicktype.io

export interface AutoAgvJSON {
  x: number
  y: number
  sizeWidth: number
  sizeHeight: number
  serverId: string
  endX: number
  endY: number
  startX: number
  startY: number
  cur: number
  waitT: number
  stepsMoved: number
  timesMoved: number
  firstText: string
  visible: boolean
  scale: number
  type: string
  originX: number
  originY: number
  alpha: number
  name: string
  textureKey: string
}

export class AutoAgv extends Actor {
  public graph: Graph
  public path: Node2D[] | null
  public curNode: Node2D
  public endNode: Node2D
  public cur: number
  public waitT: number
  public stepsMoved: number
  public timesMoved: number
  public hybridState: RunningState | undefined
  public endX: number
  public endY: number
  public firstText?: Text

  public startX: number
  public startY: number

  private sizeWidth = 32
  private sizeHeight = 32
  public serverId: string // auto generated random id in constructor

  public isDisable: boolean = false // biến cần cho xử lý overlap =))
  private disableTimer: number | null = null

  constructor(
    scene: MainScene,
    x: number,
    y: number,
    endX: number,
    endY: number,
    graph: Graph
  ) {
    super(scene, x * 32, y * 32, 'agv')
    this.startX = x * 32
    this.startY = y * 32
    this.endX = endX * 32
    this.endY = endY * 32

    this.graph = graph
    this.getBody().setSize(32, 32)
    this.setOrigin(0, 0)
    this.cur = 0
    this.waitT = 0
    this.curNode = this.graph.nodes[x][y]
    this.curNode.setState(StateOfNode2D.BUSY)
    this.endNode = this.graph.nodes[endX][endY]
    this.firstText = new Text(
      this.scene,
      endX * 32,
      endY * 32,
      'DES',
      '16px',
      '#F00'
    )
    this.path = this.calPathAStar(this.curNode, this.endNode)
    this.stepsMoved = 0
    this.timesMoved = performance.now()
    this.estimateArrivalTime(x * 32, y * 32, endX * 32, endY * 32)
    this.hybridState = new RunningState()

    this.serverId = uniqid()

    // socket: send autoAgv to server
    socketEvents.sendGameObjectToServer({
      x: this.x,
      y: this.y,
      width: this.sizeWidth,
      height: this.sizeHeight,
      serverId: this.serverId,
      gameObjectType: socketEvents.gameObjectType.autoAgv,
      clientId: this.getAgvID(),
    })
  }

  protected preUpdate(time: number, delta: number): void {
    this.hybridState?.move(this)
  }

  public calPathAStar(start: Node2D, end: Node2D): Node2D[] | null {
    const result = this.graph.calPathAStar(start, end)
    return result
  }

  public changeTarget(): void {
    const mainScene = this.scene as MainScene
    const agvsToGate1: Array<number> = mainScene.mapOfExits.get('Gate1')!
    const agvsToGate2: Array<number> = mainScene.mapOfExits.get('Gate2')!
    const choosenGate = agvsToGate1[2] < agvsToGate2[2] ? 'Gate1' : 'Gate2'
    const newArray = mainScene.mapOfExits.get(choosenGate)!
    newArray[2]++
    mainScene.mapOfExits.set(choosenGate, newArray)

    this.startX = this.endX
    this.startY = this.endY

    const xEnd: number = newArray[0]
    const yEnd: number = newArray[1]

    this.endX = xEnd * 32
    this.endY = yEnd * 32

    const finalAGVs = (
      mainScene.mapOfExits.get(choosenGate) as Array<number>
    )[2]

    this.endNode = this.graph.nodes[xEnd][yEnd]
    this.firstText = new Text(
      this.scene,
      xEnd * 32,
      yEnd * 32,
      'DES_' + finalAGVs,
      '16px',
      '#F00'
    )
    this.path = this.calPathAStar(this.curNode, this.endNode)
    this.cur = 0
    this.stepsMoved = 0
    this.timesMoved = performance.now()
    this.estimateArrivalTime(
      32 * this.startX,
      32 * this.startY,
      this.endX * 32,
      this.endY * 32
    )
  }

  public update(): void {
    if (this.isDisable) return
    super.update()
  }

  public eliminate() {
    this.firstText?.destroy()
    this.destroy()
  }

  public toJson(): AutoAgvJSON {
    return {
      x: this.x,
      y: this.y,
      sizeWidth: this.sizeWidth,
      sizeHeight: this.sizeHeight,
      serverId: this.serverId,
      endX: this.endX,
      endY: this.endY,
      startX: this.startX,
      startY: this.startY,
      cur: this.cur,
      waitT: this.waitT,
      stepsMoved: this.stepsMoved,
      timesMoved: this.timesMoved,
      firstText: this.firstText?.text || '',
      visible: this.visible,
      scale: this.scale,
      type: this.type,
      originX: this.originX,
      originY: this.originY,
      alpha: this.alpha,
      name: this.name,
      textureKey: this.texture.key,
    }
  }

  public handleOverlap() {
    this.isDisable = true
    if (this.disableTimer) clearTimeout(this.disableTimer)
    this.disableTimer = setTimeout(() => {
      this.isDisable = false
      this.disableTimer = null
    }, 3000)
  }
}
